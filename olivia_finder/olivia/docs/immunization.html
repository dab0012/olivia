<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>olivia.immunization API documentation</title>
<meta name="description" content="Olivia immunization functions â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>olivia.immunization</code></h1>
</header>
<section id="section-intro">
<p>Olivia immunization functions.</p>
<p>Immunization analyzes in which packages it is better to invest to protect the network as a whole.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Olivia immunization functions.

Immunization analyzes in which packages it is better to invest to protect the network as a whole.
&#34;&#34;&#34;

import random

import networkx as nx

from itertools import product

from olivia.lib.graphs import removed, strong_articulation_points
from olivia.model import OliviaNetwork
from olivia.networkmetrics import failure_vulnerability
from olivia.packagemetrics import Reach, DependentsCount, Impact, Surface


def immunization_delta(net, n, cost_metric=Reach, algorithm=&#39;network&#39;):
    &#34;&#34;&#34;
    Compute the improvement in network vulnerability by immunizing a certain set of packages.

    Parameters
    ----------
    net: OliviaNetwork
        Input network.
    n: container
        Container of packages to be immunized.
    cost_metric: class, optional
        Metric to measure cost.
    algorithm: &#39;network&#39; or &#39;analytic&#39;

    Returns
    -------
    result: float
        Difference of network vulnerability after immunization of the elements in n.

    Notes
    -----
    &#39;network&#39; algorithm Implements the naive algorithm of removing immunized nodes and rebuilding model from scratch,
    so it is slow for big networks. Some obvious improvements could be made, but whether or not there is a
    much better alternative is an open question.
    &#39;analytic&#39; algorithm uses only local information pertaining transitive relations of the elements to be
    immunized. This is faster for smaller networks and/or smaller immunization sets but slower otherwise. Only
    implemented for the Reach metric.

    &#34;&#34;&#34;
    if algorithm == &#39;network&#39;:
        return _immunization_delta_network(net, n, cost_metric=cost_metric)
    elif algorithm == &#39;analytic&#39; and cost_metric == Reach:
        return _immunization_delta_analytic(net, n)
    else:
        raise ValueError(&#34;Not implemented.&#34;)


def _immunization_delta_network(net, n, cost_metric=Reach):
    f1 = failure_vulnerability(net, metric=cost_metric)
    size_correction = (len(net.network) - len(n)) / len(net.network)
    with removed(net.network, n):
        immunized_net = OliviaNetwork()
        immunized_net.build_model(net.network)
        f2 = failure_vulnerability(immunized_net, metric=cost_metric)
    f2 = size_correction * f2
    return f1 - f2


def _immunization_delta_analytic(net, n):
    g = net.network
    shunt = set()
    a = set()
    d = set()
    s = set()
    for node in n:
        asc = nx.ancestors(g, node)
        a.update(asc)
        desc = nx.descendants(g, node)
        d.update(desc)
        s.update(set(product(asc | {node}, desc | {node})))
    a = a - set(n)
    d = d - set(n)
    with removed(g, n):
        for ancestor in a:
            desc = nx.descendants(g, ancestor) | {ancestor}
            shunt.update({(ancestor, f) for f in desc})
    return len(s - shunt) / len(g)


def iset_naive_ranking(set_size, ms, subset=None):
    &#34;&#34;&#34;
    Compute an immunization set by selecting top elements according to a metric.

    Parameters
    ----------
    set_size: int
        Number of packages in the immunization set.
    ms: metricStats
        Metric to measure cost.
    subset: container of nodes
        subset of packages to limit the ranking to

    Returns
    -------
    immunization_set: set
        Set of packages to be immunized.

    &#34;&#34;&#34;
    return {p[0] for p in ms.top(set_size, subset)}


def iset_delta_set_reach(olivia_model):
    &#34;&#34;&#34;
    Compute an immunization set using the DELTA SET algorithm with the Reach metric.

    DELTA SET computes upper and lower bounds for the vulnerability reduction associated to the immunization of
    each package in the network and returns a set that is guaranteed to contain the single optimum package for
    immunization.

    The resulting set size is a product of the algorithm and cannot be selected.

    Parameters
    ----------
    olivia_model: OliviaNetwork
        Input network

    Returns
    -------
    immunization_set: set
        Set of packages to be immunized.

    &#34;&#34;&#34;
    delta_upper = olivia_model.get_metric(Reach) * olivia_model.get_metric(Surface)
    delta_lower = olivia_model.get_metric(Reach) + olivia_model.get_metric(Surface) - 1
    max_lower = delta_lower.top()[0][1]
    return {p for p in olivia_model if delta_upper[p] &gt; max_lower}


def iset_delta_set_impact(olivia_model):
    &#34;&#34;&#34;
    Compute an immunization set using the DELTA SET algorithm with the Impact metric.

    DELTA SET computes upper and lower bounds for the vulnerability reduction associated to the immunization of
    each package in the network and returns a set that is guaranteed to contain the single optimum package for
    immunization.

    The resulting set size is a product of the algorithm and cannot be selected.

    Parameters
    ----------
    olivia_model: OliviaNetwork
        Input network

    Returns
    -------
    immunization_set: set
        Set of packages to be immunized.

    &#34;&#34;&#34;
    delta_upper = olivia_model.get_metric(Impact) * olivia_model.get_metric(Surface)
    delta_lower = olivia_model.get_metric(DependentsCount) * olivia_model.get_metric(Surface)
    max_lower = delta_lower.top()[0][1]
    return {p for p in olivia_model if delta_upper[p] &gt; max_lower}


def iset_sap(olivia_model, clusters=None):
    &#34;&#34;&#34;
    Compute an immunization set detecting strong articulation points (SAP).

    Immunization of SAP in the strongly connected components (SCC) of the network can be very effective
    in networks with large SCCs.

    Large SCC play a crucial role in increasing the vulnerability of networks of dependencies. Strong articulation
    points are nodes whose removal would create additional strongly connected components, thus reducing the size of
    the larger SCC.

    The appearance of SCCs in real packet networks seems to follow a model similar to the formation of the giant
    component in ErdÅ‘s-RÃ©nyi models. So the size of the largest SCC is usually much larger than the rest.

    The resulting set size is a product of the algorithm and cannot be selected.

    Parameters
    ----------
    olivia_model: OliviaNetwork
        Input network

    clusters: sets of nodes
        Iterable with sets of nodes forming SCCs in the network. If None the largest SCC is detected and used.

    Returns
    -------
    immunization_set: set
        Set of packages to be immunized corresponding to the SAP of the clusters.

    &#34;&#34;&#34;
    if clusters is None:
        clusters = [olivia_model.sorted_clusters()[0]]
    sap = set()
    for c in clusters:
        scc = olivia_model.network.subgraph(c)
        sap.update(strong_articulation_points(scc))
    return sap


def iset_random(olivia_model, set_size, indirect=False, seed=None):
    &#34;&#34;&#34;
    Compute an immunization set by randomly selecting packages.

    This method is useful for understanding the nature of a network&#39;s vulnerability and/or for
    establishing baseline immunization cases.

    Parameters
    ----------
    olivia_model: OliviaNetwork
        Input network
    set_size: int
        Number of packages in the immunization set.
    indirect: bool, optional
        Whether to use indirect selection or not. Using indirect selection the immunization set is constructed
        by randomly choosing a dependency of a randomly selected package.
    seed: int, optional
        Seed for the random number generator.

    Returns
    -------
    immunization_set: set
        Set of packages to be immunized.

    &#34;&#34;&#34;
    packages = tuple(olivia_model)
    if seed:
        random.seed(seed)
    if indirect:
        result = set()
        while len(result) != set_size:
            dependencies = []
            while len(dependencies) == 0:
                current = random.choice(packages)
                dependencies = olivia_model[current].direct_dependencies()
            result.add(random.choice(tuple(dependencies)))
        return result
    else:
        return set(random.sample(packages, k=set_size))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="olivia.immunization.immunization_delta"><code class="name flex">
<span>def <span class="ident">immunization_delta</span></span>(<span>net, n, cost_metric=olivia.packagemetrics.Reach, algorithm='network')</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the improvement in network vulnerability by immunizing a certain set of packages.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>net</code></strong> :&ensp;<code>OliviaNetwork</code></dt>
<dd>Input network.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>container</code></dt>
<dd>Container of packages to be immunized.</dd>
<dt><strong><code>cost_metric</code></strong> :&ensp;<code>class</code>, optional</dt>
<dd>Metric to measure cost.</dd>
<dt><strong><code>algorithm</code></strong> :&ensp;<code>'network'</code> or <code>'analytic'</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>float</code></dt>
<dd>Difference of network vulnerability after immunization of the elements in n.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>'network' algorithm Implements the naive algorithm of removing immunized nodes and rebuilding model from scratch,
so it is slow for big networks. Some obvious improvements could be made, but whether or not there is a
much better alternative is an open question.
'analytic' algorithm uses only local information pertaining transitive relations of the elements to be
immunized. This is faster for smaller networks and/or smaller immunization sets but slower otherwise. Only
implemented for the Reach metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def immunization_delta(net, n, cost_metric=Reach, algorithm=&#39;network&#39;):
    &#34;&#34;&#34;
    Compute the improvement in network vulnerability by immunizing a certain set of packages.

    Parameters
    ----------
    net: OliviaNetwork
        Input network.
    n: container
        Container of packages to be immunized.
    cost_metric: class, optional
        Metric to measure cost.
    algorithm: &#39;network&#39; or &#39;analytic&#39;

    Returns
    -------
    result: float
        Difference of network vulnerability after immunization of the elements in n.

    Notes
    -----
    &#39;network&#39; algorithm Implements the naive algorithm of removing immunized nodes and rebuilding model from scratch,
    so it is slow for big networks. Some obvious improvements could be made, but whether or not there is a
    much better alternative is an open question.
    &#39;analytic&#39; algorithm uses only local information pertaining transitive relations of the elements to be
    immunized. This is faster for smaller networks and/or smaller immunization sets but slower otherwise. Only
    implemented for the Reach metric.

    &#34;&#34;&#34;
    if algorithm == &#39;network&#39;:
        return _immunization_delta_network(net, n, cost_metric=cost_metric)
    elif algorithm == &#39;analytic&#39; and cost_metric == Reach:
        return _immunization_delta_analytic(net, n)
    else:
        raise ValueError(&#34;Not implemented.&#34;)</code></pre>
</details>
</dd>
<dt id="olivia.immunization.iset_delta_set_impact"><code class="name flex">
<span>def <span class="ident">iset_delta_set_impact</span></span>(<span>olivia_model)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute an immunization set using the DELTA SET algorithm with the Impact metric.</p>
<p>DELTA SET computes upper and lower bounds for the vulnerability reduction associated to the immunization of
each package in the network and returns a set that is guaranteed to contain the single optimum package for
immunization.</p>
<p>The resulting set size is a product of the algorithm and cannot be selected.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>olivia_model</code></strong> :&ensp;<code>OliviaNetwork</code></dt>
<dd>Input network</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>immunization_set</code></strong> :&ensp;<code>set</code></dt>
<dd>Set of packages to be immunized.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iset_delta_set_impact(olivia_model):
    &#34;&#34;&#34;
    Compute an immunization set using the DELTA SET algorithm with the Impact metric.

    DELTA SET computes upper and lower bounds for the vulnerability reduction associated to the immunization of
    each package in the network and returns a set that is guaranteed to contain the single optimum package for
    immunization.

    The resulting set size is a product of the algorithm and cannot be selected.

    Parameters
    ----------
    olivia_model: OliviaNetwork
        Input network

    Returns
    -------
    immunization_set: set
        Set of packages to be immunized.

    &#34;&#34;&#34;
    delta_upper = olivia_model.get_metric(Impact) * olivia_model.get_metric(Surface)
    delta_lower = olivia_model.get_metric(DependentsCount) * olivia_model.get_metric(Surface)
    max_lower = delta_lower.top()[0][1]
    return {p for p in olivia_model if delta_upper[p] &gt; max_lower}</code></pre>
</details>
</dd>
<dt id="olivia.immunization.iset_delta_set_reach"><code class="name flex">
<span>def <span class="ident">iset_delta_set_reach</span></span>(<span>olivia_model)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute an immunization set using the DELTA SET algorithm with the Reach metric.</p>
<p>DELTA SET computes upper and lower bounds for the vulnerability reduction associated to the immunization of
each package in the network and returns a set that is guaranteed to contain the single optimum package for
immunization.</p>
<p>The resulting set size is a product of the algorithm and cannot be selected.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>olivia_model</code></strong> :&ensp;<code>OliviaNetwork</code></dt>
<dd>Input network</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>immunization_set</code></strong> :&ensp;<code>set</code></dt>
<dd>Set of packages to be immunized.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iset_delta_set_reach(olivia_model):
    &#34;&#34;&#34;
    Compute an immunization set using the DELTA SET algorithm with the Reach metric.

    DELTA SET computes upper and lower bounds for the vulnerability reduction associated to the immunization of
    each package in the network and returns a set that is guaranteed to contain the single optimum package for
    immunization.

    The resulting set size is a product of the algorithm and cannot be selected.

    Parameters
    ----------
    olivia_model: OliviaNetwork
        Input network

    Returns
    -------
    immunization_set: set
        Set of packages to be immunized.

    &#34;&#34;&#34;
    delta_upper = olivia_model.get_metric(Reach) * olivia_model.get_metric(Surface)
    delta_lower = olivia_model.get_metric(Reach) + olivia_model.get_metric(Surface) - 1
    max_lower = delta_lower.top()[0][1]
    return {p for p in olivia_model if delta_upper[p] &gt; max_lower}</code></pre>
</details>
</dd>
<dt id="olivia.immunization.iset_naive_ranking"><code class="name flex">
<span>def <span class="ident">iset_naive_ranking</span></span>(<span>set_size, ms, subset=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute an immunization set by selecting top elements according to a metric.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of packages in the immunization set.</dd>
<dt><strong><code>ms</code></strong> :&ensp;<code>metricStats</code></dt>
<dd>Metric to measure cost.</dd>
<dt><strong><code>subset</code></strong> :&ensp;<code>container</code> of <code>nodes</code></dt>
<dd>subset of packages to limit the ranking to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>immunization_set</code></strong> :&ensp;<code>set</code></dt>
<dd>Set of packages to be immunized.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iset_naive_ranking(set_size, ms, subset=None):
    &#34;&#34;&#34;
    Compute an immunization set by selecting top elements according to a metric.

    Parameters
    ----------
    set_size: int
        Number of packages in the immunization set.
    ms: metricStats
        Metric to measure cost.
    subset: container of nodes
        subset of packages to limit the ranking to

    Returns
    -------
    immunization_set: set
        Set of packages to be immunized.

    &#34;&#34;&#34;
    return {p[0] for p in ms.top(set_size, subset)}</code></pre>
</details>
</dd>
<dt id="olivia.immunization.iset_random"><code class="name flex">
<span>def <span class="ident">iset_random</span></span>(<span>olivia_model, set_size, indirect=False, seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute an immunization set by randomly selecting packages.</p>
<p>This method is useful for understanding the nature of a network's vulnerability and/or for
establishing baseline immunization cases.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>olivia_model</code></strong> :&ensp;<code>OliviaNetwork</code></dt>
<dd>Input network</dd>
<dt><strong><code>set_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of packages in the immunization set.</dd>
<dt><strong><code>indirect</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to use indirect selection or not. Using indirect selection the immunization set is constructed
by randomly choosing a dependency of a randomly selected package.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Seed for the random number generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>immunization_set</code></strong> :&ensp;<code>set</code></dt>
<dd>Set of packages to be immunized.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iset_random(olivia_model, set_size, indirect=False, seed=None):
    &#34;&#34;&#34;
    Compute an immunization set by randomly selecting packages.

    This method is useful for understanding the nature of a network&#39;s vulnerability and/or for
    establishing baseline immunization cases.

    Parameters
    ----------
    olivia_model: OliviaNetwork
        Input network
    set_size: int
        Number of packages in the immunization set.
    indirect: bool, optional
        Whether to use indirect selection or not. Using indirect selection the immunization set is constructed
        by randomly choosing a dependency of a randomly selected package.
    seed: int, optional
        Seed for the random number generator.

    Returns
    -------
    immunization_set: set
        Set of packages to be immunized.

    &#34;&#34;&#34;
    packages = tuple(olivia_model)
    if seed:
        random.seed(seed)
    if indirect:
        result = set()
        while len(result) != set_size:
            dependencies = []
            while len(dependencies) == 0:
                current = random.choice(packages)
                dependencies = olivia_model[current].direct_dependencies()
            result.add(random.choice(tuple(dependencies)))
        return result
    else:
        return set(random.sample(packages, k=set_size))</code></pre>
</details>
</dd>
<dt id="olivia.immunization.iset_sap"><code class="name flex">
<span>def <span class="ident">iset_sap</span></span>(<span>olivia_model, clusters=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute an immunization set detecting strong articulation points (SAP).</p>
<p>Immunization of SAP in the strongly connected components (SCC) of the network can be very effective
in networks with large SCCs.</p>
<p>Large SCC play a crucial role in increasing the vulnerability of networks of dependencies. Strong articulation
points are nodes whose removal would create additional strongly connected components, thus reducing the size of
the larger SCC.</p>
<p>The appearance of SCCs in real packet networks seems to follow a model similar to the formation of the giant
component in ErdÅ‘s-RÃ©nyi models. So the size of the largest SCC is usually much larger than the rest.</p>
<p>The resulting set size is a product of the algorithm and cannot be selected.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>olivia_model</code></strong> :&ensp;<code>OliviaNetwork</code></dt>
<dd>Input network</dd>
<dt><strong><code>clusters</code></strong> :&ensp;<code>sets</code> of <code>nodes</code></dt>
<dd>Iterable with sets of nodes forming SCCs in the network. If None the largest SCC is detected and used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>immunization_set</code></strong> :&ensp;<code>set</code></dt>
<dd>Set of packages to be immunized corresponding to the SAP of the clusters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iset_sap(olivia_model, clusters=None):
    &#34;&#34;&#34;
    Compute an immunization set detecting strong articulation points (SAP).

    Immunization of SAP in the strongly connected components (SCC) of the network can be very effective
    in networks with large SCCs.

    Large SCC play a crucial role in increasing the vulnerability of networks of dependencies. Strong articulation
    points are nodes whose removal would create additional strongly connected components, thus reducing the size of
    the larger SCC.

    The appearance of SCCs in real packet networks seems to follow a model similar to the formation of the giant
    component in ErdÅ‘s-RÃ©nyi models. So the size of the largest SCC is usually much larger than the rest.

    The resulting set size is a product of the algorithm and cannot be selected.

    Parameters
    ----------
    olivia_model: OliviaNetwork
        Input network

    clusters: sets of nodes
        Iterable with sets of nodes forming SCCs in the network. If None the largest SCC is detected and used.

    Returns
    -------
    immunization_set: set
        Set of packages to be immunized corresponding to the SAP of the clusters.

    &#34;&#34;&#34;
    if clusters is None:
        clusters = [olivia_model.sorted_clusters()[0]]
    sap = set()
    for c in clusters:
        scc = olivia_model.network.subgraph(c)
        sap.update(strong_articulation_points(scc))
    return sap</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="olivia" href="index.html">olivia</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="olivia.immunization.immunization_delta" href="#olivia.immunization.immunization_delta">immunization_delta</a></code></li>
<li><code><a title="olivia.immunization.iset_delta_set_impact" href="#olivia.immunization.iset_delta_set_impact">iset_delta_set_impact</a></code></li>
<li><code><a title="olivia.immunization.iset_delta_set_reach" href="#olivia.immunization.iset_delta_set_reach">iset_delta_set_reach</a></code></li>
<li><code><a title="olivia.immunization.iset_naive_ranking" href="#olivia.immunization.iset_naive_ranking">iset_naive_ranking</a></code></li>
<li><code><a title="olivia.immunization.iset_random" href="#olivia.immunization.iset_random">iset_random</a></code></li>
<li><code><a title="olivia.immunization.iset_sap" href="#olivia.immunization.iset_sap">iset_sap</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>