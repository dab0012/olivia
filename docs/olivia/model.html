<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>olivia.model API documentation</title>
<meta name="description" content="Olivia Model for studying the vulnerability of package dependency networks â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>olivia.model</code></h1>
</header>
<section id="section-intro">
<p>Olivia Model for studying the vulnerability of package dependency networks.</p>
<p>Olivia stands for 'Open-source Library Indexes Vulnerability Identification and Analysis'.
Includes tools for the analysis of package dependency networks vulnerability to failures and attacks.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Olivia Model for studying the vulnerability of package dependency networks.

Olivia stands for &#39;Open-source Library Indexes Vulnerability Identification and Analysis&#39;.
Includes tools for the analysis of package dependency networks vulnerability to failures and attacks.
&#34;&#34;&#34;

import networkx as nx
import gzip
import pickle
import numpy as np

from olivia.coupling import coupling_interface, coupling_profile


class PackageInfoView:
    &#34;&#34;&#34;
    Helper class for retrieving individual package information and metrics.

    For network-wide analysis use suitable classes and methods from ~networkmetrics, ~packagemetrics or ~coupling
    instead, as individual computation can be orders of magnitude slower.
    &#34;&#34;&#34;

    def __init__(self, network, name):
        &#34;&#34;&#34;Create and initialize a PackageInfoView object.&#34;&#34;&#34;
        self._model = network
        self._name = name

    def transitive_dependencies(self):
        &#34;&#34;&#34;Return a set containing the transitive dependencies of the package.&#34;&#34;&#34;
        return nx.ancestors(self._model.network, self._name)

    def transitive_dependants(self):
        &#34;&#34;&#34;Return a set containing the transitive dependants of the package.&#34;&#34;&#34;
        return nx.descendants(self._model.network, self._name)

    def direct_dependencies(self):
        &#34;&#34;&#34;Return a set containing the direct dependencies of the package.&#34;&#34;&#34;
        return set(self._model.network.predecessors(self._name))

    def direct_dependants(self):
        &#34;&#34;&#34;Return a set containing the direct dependants of the package.&#34;&#34;&#34;
        return set(self._model.network.successors(self._name))

    def scc(self):
        &#34;&#34;&#34;
        Return the strongly connected component(SCC) of the package.

        The SCC of a package is the set of packages in the network that are strongly connected to it in
        the underlying graph -that is to say each of the packages in the scc are transitively dependant on
        each other.-
        &#34;&#34;&#34;
        dag_id = self._model.dag.graph[&#39;mapping&#39;][self._name]
        return self._model.dag.nodes[dag_id][&#39;members&#39;]

    def reach(self):
        &#34;&#34;&#34;Return the value of the Olivia reach metric for the package.&#34;&#34;&#34;
        return len(nx.descendants(self._model.network, self._name)) + 1

    def surface(self):
        &#34;&#34;&#34;Return the value of the Olivia surface metric for the package.&#34;&#34;&#34;
        return len(nx.ancestors(self._model.network, self._name)) + 1

    def impact(self):
        &#34;&#34;&#34;Return the value of the Olivia impact metric for the package.&#34;&#34;&#34;
        out_degrees = self._model.network.subgraph({self._name} |
                                                   nx.descendants(self._model.network, self._name)).out_degree()
        return np.array([n[1] for n in out_degrees]).sum()

    def coupling_interface_to(self, n):
        &#34;&#34;&#34;Return the coupling interface for this package over n.&#34;&#34;&#34;
        return coupling_interface(self._model, self._name, n)

    def coupling_interface_from(self, n):
        &#34;&#34;&#34;Return the coupling interface for n over this package.&#34;&#34;&#34;
        return coupling_interface(self._model, n, self._name)

    def coupling_profile(self):
        &#34;&#34;&#34;Return the coupling profile for this package.&#34;&#34;&#34;
        return coupling_profile(self._model, self._name)


class OliviaNetwork:
    &#34;&#34;&#34;
    Model for studying the vulnerability of package dependency networks.

    Uses a directed acyclic graph to represent the fundamental structure of the network. Also acts as a gateway for
    querying cached metric values for the packages in the network.
    &#34;&#34;&#34;

    def __init__(self, file=None):
        &#34;&#34;&#34;
        Create and initializes an OliviaNetwork object.

        Parameters
        ----------
        file: file or string
            File or file name to read an OliviaNetwork model from.

        &#34;&#34;&#34;
        if file is None:
            self._dag = {}
            self._metrics_cache = dict()  # In-model metrics cache
            self._network = {}
        else:
            self.load(file)

    def load(self, file):
        &#34;&#34;&#34;
        Load an OliviaNetwork model from file.

        Parameters
        ----------
        file: file or string
            File or file name to read an OliviaNetwork model from.

        Returns
        -------
        None

        &#34;&#34;&#34;
        with gzip.GzipFile(file, &#39;rb&#39;) as f:
            load_dict = pickle.load(f)

        self._network = nx.from_dict_of_lists(load_dict[&#39;network&#39;], create_using=nx.DiGraph())
        self._dag = load_dict[&#39;dag&#39;]
        self._metrics_cache = load_dict[&#39;cache&#39;]

    def save(self, file):
        &#34;&#34;&#34;
        Save an OliviaNetwork model to file.

        Parameters
        ----------
        file: file or string
            File or file name to write an OliviaNetwork model to.

        Returns
        -------
        None

        &#34;&#34;&#34;
        save_dict = {&#39;network&#39;: nx.to_dict_of_lists(self._network),
                     &#39;dag&#39;: self._dag,
                     &#39;cache&#39;: self._metrics_cache}

        with gzip.GzipFile(file, &#39;wb&#39;) as f:
            pickle.dump(save_dict, f, protocol=pickle.HIGHEST_PROTOCOL)

    @property
    def network(self):
        &#34;&#34;&#34;Return the package network.&#34;&#34;&#34;
        return self._network

    @property
    def dag(self):
        &#34;&#34;&#34;Return the model&#39;s underlying DAG graph.&#34;&#34;&#34;
        return self._dag

    def get_metric(self, metric_class, **kwargs):
        &#34;&#34;&#34;
        Compute or get form the internal cache metric values for the packages in the network.

        If metric values are not available, the are computed instantiating metric_class and calling compute(),and
        are subsequently stored for future use.

        Parameters
        ----------
        metric_class: class
            Class implementing compute()
        kwargs: keyword args
            Arguments for the metric class constructor.

        Returns
        -------
        ms: object
            An object containing the computed metric values. For Olivia metrics this is always a MetricStats instance.

        &#34;&#34;&#34;
        if metric_class.__name__ in self._metrics_cache:
            print(f&#39;{metric_class.__name__} retrieved from metrics cache&#39;)
        else:
            self._metrics_cache[metric_class.__name__] = metric_class(self, **kwargs).compute()
        return self._metrics_cache[metric_class.__name__]

    def sccs(self):
        &#34;&#34;&#34;
        Return a generator of strongly connected components (SCCs) present in the network.

        SCCs are sets of packages in which all the packages are transitively
        dependent on each other, so SCCs of more than one package imply the existence of cycles in the network.
        This method generates the partition into strongly connected components of the directed graph
        underlying the package network.
        &#34;&#34;&#34;
        for p in self.dag:
            yield self.dag.nodes[p][&#39;members&#39;]

    def sorted_clusters(self):
        &#34;&#34;&#34;Return a list of clusters in reverse size order.&#34;&#34;&#34;
        return sorted(self.sccs(), key=lambda x: len(x), reverse=True)

    def __getitem__(self, package):
        &#34;&#34;&#34;Return a ~DegreeInfoView of the package.&#34;&#34;&#34;
        return PackageInfoView(self, package)

    def __len__(self):
        &#34;&#34;&#34;Return the number of packages in the network.&#34;&#34;&#34;
        return len(self.network)

    def __iter__(self):
        &#34;&#34;&#34;Return an iterator over the packages in the network.&#34;&#34;&#34;
        return iter(self.network)

    def build_model(self, source):
        &#34;&#34;&#34;
        Build the model from specified source.

        Parameters
        ----------
        source: File or file name or Networkx DiGraph
            Source to build the model from. Files should be in adjacency list format.
            Filenames ending in .gz or .bz2 will be uncompressed.

        Returns
        -------
        None

        &#34;&#34;&#34;
        if isinstance(source, nx.DiGraph):
            self._network = source
        else:
            print(&#34;Reading dependencies file...&#34;)
            self._network = nx.read_adjlist(source, create_using=nx.DiGraph())
        print(&#34;Building Olivia Model&#34;)
        print(&#39;     Finding strongly connected components (SCCs)...&#39;)
        scc = nx.strongly_connected_components(self._network)
        print(&#39;     Building condensation network...&#39;)
        GC = nx.condensation(self._network, list(scc))
        print(&#39;     Adding structural meta-data...&#39;)

        # Model includes weighted edges to represent
        # ingoing/outgoing dependencies to/from SCC
        for e in GC.edges:
            GC.edges[e][&#39;weight&#39;] = 0
        for n in GC.nodes:
            GC.nodes[n][&#39;intra_edges&#39;] = 0

        for n in self._network:
            for e in self._network.in_edges(n):
                u, v = e
                map_u = GC.graph[&#39;mapping&#39;][u]
                map_v = GC.graph[&#39;mapping&#39;][v]
                if map_u == map_v:
                    # Number of edges inside SCC
                    GC.nodes[map_u][&#39;intra_edges&#39;] += 1
                else:
                    # Weight for edge to/from SCC
                    GC.edges[(map_u, map_v)][&#39;weight&#39;] += 1
        self._dag = GC
        print(&#34;     Done&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="olivia.model.OliviaNetwork"><code class="flex name class">
<span>class <span class="ident">OliviaNetwork</span></span>
<span>(</span><span>file=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Model for studying the vulnerability of package dependency networks.</p>
<p>Uses a directed acyclic graph to represent the fundamental structure of the network. Also acts as a gateway for
querying cached metric values for the packages in the network.</p>
<p>Create and initializes an OliviaNetwork object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>file</code> or <code>string</code></dt>
<dd>File or file name to read an OliviaNetwork model from.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OliviaNetwork:
    &#34;&#34;&#34;
    Model for studying the vulnerability of package dependency networks.

    Uses a directed acyclic graph to represent the fundamental structure of the network. Also acts as a gateway for
    querying cached metric values for the packages in the network.
    &#34;&#34;&#34;

    def __init__(self, file=None):
        &#34;&#34;&#34;
        Create and initializes an OliviaNetwork object.

        Parameters
        ----------
        file: file or string
            File or file name to read an OliviaNetwork model from.

        &#34;&#34;&#34;
        if file is None:
            self._dag = {}
            self._metrics_cache = dict()  # In-model metrics cache
            self._network = {}
        else:
            self.load(file)

    def load(self, file):
        &#34;&#34;&#34;
        Load an OliviaNetwork model from file.

        Parameters
        ----------
        file: file or string
            File or file name to read an OliviaNetwork model from.

        Returns
        -------
        None

        &#34;&#34;&#34;
        with gzip.GzipFile(file, &#39;rb&#39;) as f:
            load_dict = pickle.load(f)

        self._network = nx.from_dict_of_lists(load_dict[&#39;network&#39;], create_using=nx.DiGraph())
        self._dag = load_dict[&#39;dag&#39;]
        self._metrics_cache = load_dict[&#39;cache&#39;]

    def save(self, file):
        &#34;&#34;&#34;
        Save an OliviaNetwork model to file.

        Parameters
        ----------
        file: file or string
            File or file name to write an OliviaNetwork model to.

        Returns
        -------
        None

        &#34;&#34;&#34;
        save_dict = {&#39;network&#39;: nx.to_dict_of_lists(self._network),
                     &#39;dag&#39;: self._dag,
                     &#39;cache&#39;: self._metrics_cache}

        with gzip.GzipFile(file, &#39;wb&#39;) as f:
            pickle.dump(save_dict, f, protocol=pickle.HIGHEST_PROTOCOL)

    @property
    def network(self):
        &#34;&#34;&#34;Return the package network.&#34;&#34;&#34;
        return self._network

    @property
    def dag(self):
        &#34;&#34;&#34;Return the model&#39;s underlying DAG graph.&#34;&#34;&#34;
        return self._dag

    def get_metric(self, metric_class, **kwargs):
        &#34;&#34;&#34;
        Compute or get form the internal cache metric values for the packages in the network.

        If metric values are not available, the are computed instantiating metric_class and calling compute(),and
        are subsequently stored for future use.

        Parameters
        ----------
        metric_class: class
            Class implementing compute()
        kwargs: keyword args
            Arguments for the metric class constructor.

        Returns
        -------
        ms: object
            An object containing the computed metric values. For Olivia metrics this is always a MetricStats instance.

        &#34;&#34;&#34;
        if metric_class.__name__ in self._metrics_cache:
            print(f&#39;{metric_class.__name__} retrieved from metrics cache&#39;)
        else:
            self._metrics_cache[metric_class.__name__] = metric_class(self, **kwargs).compute()
        return self._metrics_cache[metric_class.__name__]

    def sccs(self):
        &#34;&#34;&#34;
        Return a generator of strongly connected components (SCCs) present in the network.

        SCCs are sets of packages in which all the packages are transitively
        dependent on each other, so SCCs of more than one package imply the existence of cycles in the network.
        This method generates the partition into strongly connected components of the directed graph
        underlying the package network.
        &#34;&#34;&#34;
        for p in self.dag:
            yield self.dag.nodes[p][&#39;members&#39;]

    def sorted_clusters(self):
        &#34;&#34;&#34;Return a list of clusters in reverse size order.&#34;&#34;&#34;
        return sorted(self.sccs(), key=lambda x: len(x), reverse=True)

    def __getitem__(self, package):
        &#34;&#34;&#34;Return a ~DegreeInfoView of the package.&#34;&#34;&#34;
        return PackageInfoView(self, package)

    def __len__(self):
        &#34;&#34;&#34;Return the number of packages in the network.&#34;&#34;&#34;
        return len(self.network)

    def __iter__(self):
        &#34;&#34;&#34;Return an iterator over the packages in the network.&#34;&#34;&#34;
        return iter(self.network)

    def build_model(self, source):
        &#34;&#34;&#34;
        Build the model from specified source.

        Parameters
        ----------
        source: File or file name or Networkx DiGraph
            Source to build the model from. Files should be in adjacency list format.
            Filenames ending in .gz or .bz2 will be uncompressed.

        Returns
        -------
        None

        &#34;&#34;&#34;
        if isinstance(source, nx.DiGraph):
            self._network = source
        else:
            print(&#34;Reading dependencies file...&#34;)
            self._network = nx.read_adjlist(source, create_using=nx.DiGraph())
        print(&#34;Building Olivia Model&#34;)
        print(&#39;     Finding strongly connected components (SCCs)...&#39;)
        scc = nx.strongly_connected_components(self._network)
        print(&#39;     Building condensation network...&#39;)
        GC = nx.condensation(self._network, list(scc))
        print(&#39;     Adding structural meta-data...&#39;)

        # Model includes weighted edges to represent
        # ingoing/outgoing dependencies to/from SCC
        for e in GC.edges:
            GC.edges[e][&#39;weight&#39;] = 0
        for n in GC.nodes:
            GC.nodes[n][&#39;intra_edges&#39;] = 0

        for n in self._network:
            for e in self._network.in_edges(n):
                u, v = e
                map_u = GC.graph[&#39;mapping&#39;][u]
                map_v = GC.graph[&#39;mapping&#39;][v]
                if map_u == map_v:
                    # Number of edges inside SCC
                    GC.nodes[map_u][&#39;intra_edges&#39;] += 1
                else:
                    # Weight for edge to/from SCC
                    GC.edges[(map_u, map_v)][&#39;weight&#39;] += 1
        self._dag = GC
        print(&#34;     Done&#34;)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="olivia.model.OliviaNetwork.dag"><code class="name">var <span class="ident">dag</span></code></dt>
<dd>
<div class="desc"><p>Return the model's underlying DAG graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dag(self):
    &#34;&#34;&#34;Return the model&#39;s underlying DAG graph.&#34;&#34;&#34;
    return self._dag</code></pre>
</details>
</dd>
<dt id="olivia.model.OliviaNetwork.network"><code class="name">var <span class="ident">network</span></code></dt>
<dd>
<div class="desc"><p>Return the package network.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def network(self):
    &#34;&#34;&#34;Return the package network.&#34;&#34;&#34;
    return self._network</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="olivia.model.OliviaNetwork.build_model"><code class="name flex">
<span>def <span class="ident">build_model</span></span>(<span>self, source)</span>
</code></dt>
<dd>
<div class="desc"><p>Build the model from specified source.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>source</code></strong> :&ensp;<code>File</code> or <code>file name</code> or <code>Networkx DiGraph</code></dt>
<dd>Source to build the model from. Files should be in adjacency list format.
Filenames ending in .gz or .bz2 will be uncompressed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_model(self, source):
    &#34;&#34;&#34;
    Build the model from specified source.

    Parameters
    ----------
    source: File or file name or Networkx DiGraph
        Source to build the model from. Files should be in adjacency list format.
        Filenames ending in .gz or .bz2 will be uncompressed.

    Returns
    -------
    None

    &#34;&#34;&#34;
    if isinstance(source, nx.DiGraph):
        self._network = source
    else:
        print(&#34;Reading dependencies file...&#34;)
        self._network = nx.read_adjlist(source, create_using=nx.DiGraph())
    print(&#34;Building Olivia Model&#34;)
    print(&#39;     Finding strongly connected components (SCCs)...&#39;)
    scc = nx.strongly_connected_components(self._network)
    print(&#39;     Building condensation network...&#39;)
    GC = nx.condensation(self._network, list(scc))
    print(&#39;     Adding structural meta-data...&#39;)

    # Model includes weighted edges to represent
    # ingoing/outgoing dependencies to/from SCC
    for e in GC.edges:
        GC.edges[e][&#39;weight&#39;] = 0
    for n in GC.nodes:
        GC.nodes[n][&#39;intra_edges&#39;] = 0

    for n in self._network:
        for e in self._network.in_edges(n):
            u, v = e
            map_u = GC.graph[&#39;mapping&#39;][u]
            map_v = GC.graph[&#39;mapping&#39;][v]
            if map_u == map_v:
                # Number of edges inside SCC
                GC.nodes[map_u][&#39;intra_edges&#39;] += 1
            else:
                # Weight for edge to/from SCC
                GC.edges[(map_u, map_v)][&#39;weight&#39;] += 1
    self._dag = GC
    print(&#34;     Done&#34;)</code></pre>
</details>
</dd>
<dt id="olivia.model.OliviaNetwork.get_metric"><code class="name flex">
<span>def <span class="ident">get_metric</span></span>(<span>self, metric_class, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute or get form the internal cache metric values for the packages in the network.</p>
<p>If metric values are not available, the are computed instantiating metric_class and calling compute(),and
are subsequently stored for future use.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>metric_class</code></strong> :&ensp;<code>class</code></dt>
<dd>Class implementing compute()</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>keyword args</code></dt>
<dd>Arguments for the metric class constructor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ms</code></strong> :&ensp;<code>object</code></dt>
<dd>An object containing the computed metric values. For Olivia metrics this is always a MetricStats instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_metric(self, metric_class, **kwargs):
    &#34;&#34;&#34;
    Compute or get form the internal cache metric values for the packages in the network.

    If metric values are not available, the are computed instantiating metric_class and calling compute(),and
    are subsequently stored for future use.

    Parameters
    ----------
    metric_class: class
        Class implementing compute()
    kwargs: keyword args
        Arguments for the metric class constructor.

    Returns
    -------
    ms: object
        An object containing the computed metric values. For Olivia metrics this is always a MetricStats instance.

    &#34;&#34;&#34;
    if metric_class.__name__ in self._metrics_cache:
        print(f&#39;{metric_class.__name__} retrieved from metrics cache&#39;)
    else:
        self._metrics_cache[metric_class.__name__] = metric_class(self, **kwargs).compute()
    return self._metrics_cache[metric_class.__name__]</code></pre>
</details>
</dd>
<dt id="olivia.model.OliviaNetwork.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, file)</span>
</code></dt>
<dd>
<div class="desc"><p>Load an OliviaNetwork model from file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>file</code> or <code>string</code></dt>
<dd>File or file name to read an OliviaNetwork model from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, file):
    &#34;&#34;&#34;
    Load an OliviaNetwork model from file.

    Parameters
    ----------
    file: file or string
        File or file name to read an OliviaNetwork model from.

    Returns
    -------
    None

    &#34;&#34;&#34;
    with gzip.GzipFile(file, &#39;rb&#39;) as f:
        load_dict = pickle.load(f)

    self._network = nx.from_dict_of_lists(load_dict[&#39;network&#39;], create_using=nx.DiGraph())
    self._dag = load_dict[&#39;dag&#39;]
    self._metrics_cache = load_dict[&#39;cache&#39;]</code></pre>
</details>
</dd>
<dt id="olivia.model.OliviaNetwork.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, file)</span>
</code></dt>
<dd>
<div class="desc"><p>Save an OliviaNetwork model to file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>file</code> or <code>string</code></dt>
<dd>File or file name to write an OliviaNetwork model to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, file):
    &#34;&#34;&#34;
    Save an OliviaNetwork model to file.

    Parameters
    ----------
    file: file or string
        File or file name to write an OliviaNetwork model to.

    Returns
    -------
    None

    &#34;&#34;&#34;
    save_dict = {&#39;network&#39;: nx.to_dict_of_lists(self._network),
                 &#39;dag&#39;: self._dag,
                 &#39;cache&#39;: self._metrics_cache}

    with gzip.GzipFile(file, &#39;wb&#39;) as f:
        pickle.dump(save_dict, f, protocol=pickle.HIGHEST_PROTOCOL)</code></pre>
</details>
</dd>
<dt id="olivia.model.OliviaNetwork.sccs"><code class="name flex">
<span>def <span class="ident">sccs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a generator of strongly connected components (SCCs) present in the network.</p>
<p>SCCs are sets of packages in which all the packages are transitively
dependent on each other, so SCCs of more than one package imply the existence of cycles in the network.
This method generates the partition into strongly connected components of the directed graph
underlying the package network.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sccs(self):
    &#34;&#34;&#34;
    Return a generator of strongly connected components (SCCs) present in the network.

    SCCs are sets of packages in which all the packages are transitively
    dependent on each other, so SCCs of more than one package imply the existence of cycles in the network.
    This method generates the partition into strongly connected components of the directed graph
    underlying the package network.
    &#34;&#34;&#34;
    for p in self.dag:
        yield self.dag.nodes[p][&#39;members&#39;]</code></pre>
</details>
</dd>
<dt id="olivia.model.OliviaNetwork.sorted_clusters"><code class="name flex">
<span>def <span class="ident">sorted_clusters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of clusters in reverse size order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sorted_clusters(self):
    &#34;&#34;&#34;Return a list of clusters in reverse size order.&#34;&#34;&#34;
    return sorted(self.sccs(), key=lambda x: len(x), reverse=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="olivia.model.PackageInfoView"><code class="flex name class">
<span>class <span class="ident">PackageInfoView</span></span>
<span>(</span><span>network, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class for retrieving individual package information and metrics.</p>
<p>For network-wide analysis use suitable classes and methods from ~networkmetrics, ~packagemetrics or ~coupling
instead, as individual computation can be orders of magnitude slower.</p>
<p>Create and initialize a PackageInfoView object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PackageInfoView:
    &#34;&#34;&#34;
    Helper class for retrieving individual package information and metrics.

    For network-wide analysis use suitable classes and methods from ~networkmetrics, ~packagemetrics or ~coupling
    instead, as individual computation can be orders of magnitude slower.
    &#34;&#34;&#34;

    def __init__(self, network, name):
        &#34;&#34;&#34;Create and initialize a PackageInfoView object.&#34;&#34;&#34;
        self._model = network
        self._name = name

    def transitive_dependencies(self):
        &#34;&#34;&#34;Return a set containing the transitive dependencies of the package.&#34;&#34;&#34;
        return nx.ancestors(self._model.network, self._name)

    def transitive_dependants(self):
        &#34;&#34;&#34;Return a set containing the transitive dependants of the package.&#34;&#34;&#34;
        return nx.descendants(self._model.network, self._name)

    def direct_dependencies(self):
        &#34;&#34;&#34;Return a set containing the direct dependencies of the package.&#34;&#34;&#34;
        return set(self._model.network.predecessors(self._name))

    def direct_dependants(self):
        &#34;&#34;&#34;Return a set containing the direct dependants of the package.&#34;&#34;&#34;
        return set(self._model.network.successors(self._name))

    def scc(self):
        &#34;&#34;&#34;
        Return the strongly connected component(SCC) of the package.

        The SCC of a package is the set of packages in the network that are strongly connected to it in
        the underlying graph -that is to say each of the packages in the scc are transitively dependant on
        each other.-
        &#34;&#34;&#34;
        dag_id = self._model.dag.graph[&#39;mapping&#39;][self._name]
        return self._model.dag.nodes[dag_id][&#39;members&#39;]

    def reach(self):
        &#34;&#34;&#34;Return the value of the Olivia reach metric for the package.&#34;&#34;&#34;
        return len(nx.descendants(self._model.network, self._name)) + 1

    def surface(self):
        &#34;&#34;&#34;Return the value of the Olivia surface metric for the package.&#34;&#34;&#34;
        return len(nx.ancestors(self._model.network, self._name)) + 1

    def impact(self):
        &#34;&#34;&#34;Return the value of the Olivia impact metric for the package.&#34;&#34;&#34;
        out_degrees = self._model.network.subgraph({self._name} |
                                                   nx.descendants(self._model.network, self._name)).out_degree()
        return np.array([n[1] for n in out_degrees]).sum()

    def coupling_interface_to(self, n):
        &#34;&#34;&#34;Return the coupling interface for this package over n.&#34;&#34;&#34;
        return coupling_interface(self._model, self._name, n)

    def coupling_interface_from(self, n):
        &#34;&#34;&#34;Return the coupling interface for n over this package.&#34;&#34;&#34;
        return coupling_interface(self._model, n, self._name)

    def coupling_profile(self):
        &#34;&#34;&#34;Return the coupling profile for this package.&#34;&#34;&#34;
        return coupling_profile(self._model, self._name)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="olivia.model.PackageInfoView.coupling_interface_from"><code class="name flex">
<span>def <span class="ident">coupling_interface_from</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the coupling interface for n over this package.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coupling_interface_from(self, n):
    &#34;&#34;&#34;Return the coupling interface for n over this package.&#34;&#34;&#34;
    return coupling_interface(self._model, n, self._name)</code></pre>
</details>
</dd>
<dt id="olivia.model.PackageInfoView.coupling_interface_to"><code class="name flex">
<span>def <span class="ident">coupling_interface_to</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the coupling interface for this package over n.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coupling_interface_to(self, n):
    &#34;&#34;&#34;Return the coupling interface for this package over n.&#34;&#34;&#34;
    return coupling_interface(self._model, self._name, n)</code></pre>
</details>
</dd>
<dt id="olivia.model.PackageInfoView.coupling_profile"><code class="name flex">
<span>def <span class="ident">coupling_profile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the coupling profile for this package.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coupling_profile(self):
    &#34;&#34;&#34;Return the coupling profile for this package.&#34;&#34;&#34;
    return coupling_profile(self._model, self._name)</code></pre>
</details>
</dd>
<dt id="olivia.model.PackageInfoView.direct_dependants"><code class="name flex">
<span>def <span class="ident">direct_dependants</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a set containing the direct dependants of the package.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def direct_dependants(self):
    &#34;&#34;&#34;Return a set containing the direct dependants of the package.&#34;&#34;&#34;
    return set(self._model.network.successors(self._name))</code></pre>
</details>
</dd>
<dt id="olivia.model.PackageInfoView.direct_dependencies"><code class="name flex">
<span>def <span class="ident">direct_dependencies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a set containing the direct dependencies of the package.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def direct_dependencies(self):
    &#34;&#34;&#34;Return a set containing the direct dependencies of the package.&#34;&#34;&#34;
    return set(self._model.network.predecessors(self._name))</code></pre>
</details>
</dd>
<dt id="olivia.model.PackageInfoView.impact"><code class="name flex">
<span>def <span class="ident">impact</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the value of the Olivia impact metric for the package.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def impact(self):
    &#34;&#34;&#34;Return the value of the Olivia impact metric for the package.&#34;&#34;&#34;
    out_degrees = self._model.network.subgraph({self._name} |
                                               nx.descendants(self._model.network, self._name)).out_degree()
    return np.array([n[1] for n in out_degrees]).sum()</code></pre>
</details>
</dd>
<dt id="olivia.model.PackageInfoView.reach"><code class="name flex">
<span>def <span class="ident">reach</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the value of the Olivia reach metric for the package.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reach(self):
    &#34;&#34;&#34;Return the value of the Olivia reach metric for the package.&#34;&#34;&#34;
    return len(nx.descendants(self._model.network, self._name)) + 1</code></pre>
</details>
</dd>
<dt id="olivia.model.PackageInfoView.scc"><code class="name flex">
<span>def <span class="ident">scc</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the strongly connected component(SCC) of the package.</p>
<p>The SCC of a package is the set of packages in the network that are strongly connected to it in
the underlying graph -that is to say each of the packages in the scc are transitively dependant on
each other.-</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scc(self):
    &#34;&#34;&#34;
    Return the strongly connected component(SCC) of the package.

    The SCC of a package is the set of packages in the network that are strongly connected to it in
    the underlying graph -that is to say each of the packages in the scc are transitively dependant on
    each other.-
    &#34;&#34;&#34;
    dag_id = self._model.dag.graph[&#39;mapping&#39;][self._name]
    return self._model.dag.nodes[dag_id][&#39;members&#39;]</code></pre>
</details>
</dd>
<dt id="olivia.model.PackageInfoView.surface"><code class="name flex">
<span>def <span class="ident">surface</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the value of the Olivia surface metric for the package.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def surface(self):
    &#34;&#34;&#34;Return the value of the Olivia surface metric for the package.&#34;&#34;&#34;
    return len(nx.ancestors(self._model.network, self._name)) + 1</code></pre>
</details>
</dd>
<dt id="olivia.model.PackageInfoView.transitive_dependants"><code class="name flex">
<span>def <span class="ident">transitive_dependants</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a set containing the transitive dependants of the package.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transitive_dependants(self):
    &#34;&#34;&#34;Return a set containing the transitive dependants of the package.&#34;&#34;&#34;
    return nx.descendants(self._model.network, self._name)</code></pre>
</details>
</dd>
<dt id="olivia.model.PackageInfoView.transitive_dependencies"><code class="name flex">
<span>def <span class="ident">transitive_dependencies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a set containing the transitive dependencies of the package.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transitive_dependencies(self):
    &#34;&#34;&#34;Return a set containing the transitive dependencies of the package.&#34;&#34;&#34;
    return nx.ancestors(self._model.network, self._name)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="olivia" href="index.html">olivia</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="olivia.model.OliviaNetwork" href="#olivia.model.OliviaNetwork">OliviaNetwork</a></code></h4>
<ul class="two-column">
<li><code><a title="olivia.model.OliviaNetwork.build_model" href="#olivia.model.OliviaNetwork.build_model">build_model</a></code></li>
<li><code><a title="olivia.model.OliviaNetwork.dag" href="#olivia.model.OliviaNetwork.dag">dag</a></code></li>
<li><code><a title="olivia.model.OliviaNetwork.get_metric" href="#olivia.model.OliviaNetwork.get_metric">get_metric</a></code></li>
<li><code><a title="olivia.model.OliviaNetwork.load" href="#olivia.model.OliviaNetwork.load">load</a></code></li>
<li><code><a title="olivia.model.OliviaNetwork.network" href="#olivia.model.OliviaNetwork.network">network</a></code></li>
<li><code><a title="olivia.model.OliviaNetwork.save" href="#olivia.model.OliviaNetwork.save">save</a></code></li>
<li><code><a title="olivia.model.OliviaNetwork.sccs" href="#olivia.model.OliviaNetwork.sccs">sccs</a></code></li>
<li><code><a title="olivia.model.OliviaNetwork.sorted_clusters" href="#olivia.model.OliviaNetwork.sorted_clusters">sorted_clusters</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="olivia.model.PackageInfoView" href="#olivia.model.PackageInfoView">PackageInfoView</a></code></h4>
<ul class="">
<li><code><a title="olivia.model.PackageInfoView.coupling_interface_from" href="#olivia.model.PackageInfoView.coupling_interface_from">coupling_interface_from</a></code></li>
<li><code><a title="olivia.model.PackageInfoView.coupling_interface_to" href="#olivia.model.PackageInfoView.coupling_interface_to">coupling_interface_to</a></code></li>
<li><code><a title="olivia.model.PackageInfoView.coupling_profile" href="#olivia.model.PackageInfoView.coupling_profile">coupling_profile</a></code></li>
<li><code><a title="olivia.model.PackageInfoView.direct_dependants" href="#olivia.model.PackageInfoView.direct_dependants">direct_dependants</a></code></li>
<li><code><a title="olivia.model.PackageInfoView.direct_dependencies" href="#olivia.model.PackageInfoView.direct_dependencies">direct_dependencies</a></code></li>
<li><code><a title="olivia.model.PackageInfoView.impact" href="#olivia.model.PackageInfoView.impact">impact</a></code></li>
<li><code><a title="olivia.model.PackageInfoView.reach" href="#olivia.model.PackageInfoView.reach">reach</a></code></li>
<li><code><a title="olivia.model.PackageInfoView.scc" href="#olivia.model.PackageInfoView.scc">scc</a></code></li>
<li><code><a title="olivia.model.PackageInfoView.surface" href="#olivia.model.PackageInfoView.surface">surface</a></code></li>
<li><code><a title="olivia.model.PackageInfoView.transitive_dependants" href="#olivia.model.PackageInfoView.transitive_dependants">transitive_dependants</a></code></li>
<li><code><a title="olivia.model.PackageInfoView.transitive_dependencies" href="#olivia.model.PackageInfoView.transitive_dependencies">transitive_dependencies</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>